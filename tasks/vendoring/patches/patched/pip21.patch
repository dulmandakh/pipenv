diff --git a/pipenv/patched/notpip/__main__.py b/pipenv/patched/notpip/__main__.py
index 1005489f..859f52ac 100644
--- a/pipenv/patched/notpip/__main__.py
+++ b/pipenv/patched/notpip/__main__.py
@@ -16,7 +16,9 @@ if __package__ == '':
     # Resulting path is the name of the wheel itself
     # Add that to sys.path so we can import pip
     path = os.path.dirname(os.path.dirname(__file__))
+    pipenv = os.path.dirname(os.path.dirname(path))
     sys.path.insert(0, path)
+    sys.path.insert(0, pipenv)
 
 from pip._internal.cli.main import main as _main
 
diff --git a/pipenv/patched/notpip/_internal/build_env.py b/pipenv/patched/notpip/_internal/build_env.py
index a587d9f7..e6a0d5fd 100644
--- a/pipenv/patched/notpip/_internal/build_env.py
+++ b/pipenv/patched/notpip/_internal/build_env.py
@@ -172,8 +172,9 @@ class BuildEnvironment:
         prefix.setup = True
         if not requirements:
             return
+        sys_executable = os.environ.get('PIP_PYTHON_PATH', sys.executable)
         args = [
-            sys.executable, os.path.dirname(pip_location), 'install',
+            sys_executable, os.path.dirname(pip_location), 'install',
             '--ignore-installed', '--no-user', '--prefix', prefix.path,
             '--no-warn-script-location',
         ]  # type: List[str]
diff --git a/pipenv/patched/notpip/_internal/commands/__init__.py b/pipenv/patched/notpip/_internal/commands/__init__.py
index f2411201..c29bdead 100644
--- a/pipenv/patched/notpip/_internal/commands/__init__.py
+++ b/pipenv/patched/notpip/_internal/commands/__init__.py
@@ -17,7 +17,7 @@ CommandInfo = namedtuple('CommandInfo', 'module_path, class_name, summary')
 
 # The ordering matters for help display.
 #    Also, even though the module path starts with the same
-# "pip._internal.commands" prefix in each case, we include the full path
+# "pipenv.patched.notpip._internal.commands" prefix in each case, we include the full path
 # because it makes testing easier (specifically when modifying commands_dict
 # in test setup / teardown by adding info for a FakeCommand class defined
 # in a test-related module).
@@ -25,63 +25,63 @@ CommandInfo = namedtuple('CommandInfo', 'module_path, class_name, summary')
 # so that the ordering won't be lost when using Python 2.7.
 commands_dict = OrderedDict([
     ('install', CommandInfo(
-        'pip._internal.commands.install', 'InstallCommand',
+        'pipenv.patched.notpip._internal.commands.install', 'InstallCommand',
         'Install packages.',
     )),
     ('download', CommandInfo(
-        'pip._internal.commands.download', 'DownloadCommand',
+        'pipenv.patched.notpip._internal.commands.download', 'DownloadCommand',
         'Download packages.',
     )),
     ('uninstall', CommandInfo(
-        'pip._internal.commands.uninstall', 'UninstallCommand',
+        'pipenv.patched.notpip._internal.commands.uninstall', 'UninstallCommand',
         'Uninstall packages.',
     )),
     ('freeze', CommandInfo(
-        'pip._internal.commands.freeze', 'FreezeCommand',
+        'pipenv.patched.notpip._internal.commands.freeze', 'FreezeCommand',
         'Output installed packages in requirements format.',
     )),
     ('list', CommandInfo(
-        'pip._internal.commands.list', 'ListCommand',
+        'pipenv.patched.notpip._internal.commands.list', 'ListCommand',
         'List installed packages.',
     )),
     ('show', CommandInfo(
-        'pip._internal.commands.show', 'ShowCommand',
+        'pipenv.patched.notpip._internal.commands.show', 'ShowCommand',
         'Show information about installed packages.',
     )),
     ('check', CommandInfo(
-        'pip._internal.commands.check', 'CheckCommand',
+        'pipenv.patched.notpip._internal.commands.check', 'CheckCommand',
         'Verify installed packages have compatible dependencies.',
     )),
     ('config', CommandInfo(
-        'pip._internal.commands.configuration', 'ConfigurationCommand',
+        'pipenv.patched.notpip._internal.commands.configuration', 'ConfigurationCommand',
         'Manage local and global configuration.',
     )),
     ('search', CommandInfo(
-        'pip._internal.commands.search', 'SearchCommand',
+        'pipenv.patched.notpip._internal.commands.search', 'SearchCommand',
         'Search PyPI for packages.',
     )),
     ('cache', CommandInfo(
-        'pip._internal.commands.cache', 'CacheCommand',
+        'pipenv.patched.notpip._internal.commands.cache', 'CacheCommand',
         "Inspect and manage pip's wheel cache.",
     )),
     ('wheel', CommandInfo(
-        'pip._internal.commands.wheel', 'WheelCommand',
+        'pipenv.patched.notpip._internal.commands.wheel', 'WheelCommand',
         'Build wheels from your requirements.',
     )),
     ('hash', CommandInfo(
-        'pip._internal.commands.hash', 'HashCommand',
+        'pipenv.patched.notpip._internal.commands.hash', 'HashCommand',
         'Compute hashes of package archives.',
     )),
     ('completion', CommandInfo(
-        'pip._internal.commands.completion', 'CompletionCommand',
+        'pipenv.patched.notpip._internal.commands.completion', 'CompletionCommand',
         'A helper command used for command completion.',
     )),
     ('debug', CommandInfo(
-        'pip._internal.commands.debug', 'DebugCommand',
+        'pipenv.patched.notpip._internal.commands.debug', 'DebugCommand',
         'Show information useful for debugging.',
     )),
     ('help', CommandInfo(
-        'pip._internal.commands.help', 'HelpCommand',
+        'pipenv.patched.notpip._internal.commands.help', 'HelpCommand',
         'Show help for commands.',
     )),
 ])  # type: OrderedDict[str, CommandInfo]
diff --git a/pipenv/patched/notpip/_internal/commands/install.py b/pipenv/patched/notpip/_internal/commands/install.py
index e303adf8..d5452ec4 100644
--- a/pipenv/patched/notpip/_internal/commands/install.py
+++ b/pipenv/patched/notpip/_internal/commands/install.py
@@ -324,7 +324,7 @@ class InstallCommand(RequirementCommand):
             else:
                 # If we're not replacing an already installed pip,
                 # we're not modifying it.
-                modifying_pip = pip_req.satisfied_by is None
+                modifying_pip = getattr(pip_req, "satisfied_by", None) is None
             protect_pip_from_modification_on_windows(
                 modifying_pip=modifying_pip
             )
diff --git a/pipenv/patched/notpip/_internal/index/package_finder.py b/pipenv/patched/notpip/_internal/index/package_finder.py
index 73118892..c41c6d8c 100644
--- a/pipenv/patched/notpip/_internal/index/package_finder.py
+++ b/pipenv/patched/notpip/_internal/index/package_finder.py
@@ -118,6 +118,7 @@ class LinkEvaluator:
         target_python,   # type: TargetPython
         allow_yanked,    # type: bool
         ignore_requires_python=None,  # type: Optional[bool]
+        ignore_compatibility=None,  # type: Optional[bool]
     ):
         # type: (...) -> None
         """
@@ -136,15 +137,20 @@ class LinkEvaluator:
         :param ignore_requires_python: Whether to ignore incompatible
             PEP 503 "data-requires-python" values in HTML links. Defaults
             to False.
+        :param Optional[bool] ignore_compatibility: Whether to ignore
+            compatibility of python versions and allow all versions of packages.
         """
         if ignore_requires_python is None:
             ignore_requires_python = False
+        if ignore_compatibility is None:
+            ignore_compatibility = True
 
         self._allow_yanked = allow_yanked
         self._canonical_name = canonical_name
         self._ignore_requires_python = ignore_requires_python
         self._formats = formats
         self._target_python = target_python
+        self._ignore_compatibility = ignore_compatibility
 
         self.project_name = project_name
 
@@ -172,11 +178,11 @@ class LinkEvaluator:
                 return (False, 'not a file')
             if ext not in SUPPORTED_EXTENSIONS:
                 return (False, f'unsupported archive format: {ext}')
-            if "binary" not in self._formats and ext == WHEEL_EXTENSION:
+            if "binary" not in self._formats and ext == WHEEL_EXTENSION and not self._ignore_compatibility:
                 reason = 'No binaries permitted for {}'.format(
                     self.project_name)
                 return (False, reason)
-            if "macosx10" in link.path and ext == '.zip':
+            if "macosx10" in link.path and ext == '.zip' and not self._ignore_compatibility:
                 return (False, 'macosx10 one')
             if ext == WHEEL_EXTENSION:
                 try:
@@ -189,7 +195,7 @@ class LinkEvaluator:
                     return (False, reason)
 
                 supported_tags = self._target_python.get_tags()
-                if not wheel.supported(supported_tags):
+                if not wheel.supported(supported_tags) and not self._ignore_compatibility:
                     # Include the wheel's tags in the reason string to
                     # simplify troubleshooting compatibility issues.
                     file_tags = wheel.get_formatted_file_tags()
@@ -226,7 +232,7 @@ class LinkEvaluator:
             link, version_info=self._target_python.py_version_info,
             ignore_requires_python=self._ignore_requires_python,
         )
-        if not supports_python:
+        if not supports_python and not self._ignore_compatibility:
             # Return None for the reason text to suppress calling
             # _log_skipped_link().
             return (False, None)
@@ -479,8 +485,8 @@ class CandidateEvaluator:
 
         return sorted(filtered_applicable_candidates, key=self._sort_key)
 
-    def _sort_key(self, candidate):
-        # type: (InstallationCandidate) -> CandidateSortingKey
+    def _sort_key(self, candidate, ignore_compatibility=True):
+        # type: (InstallationCandidate, bool) -> CandidateSortingKey
         """
         Function to pass as the `key` argument to a call to sorted() to sort
         InstallationCandidates by preference.
@@ -518,14 +524,18 @@ class CandidateEvaluator:
         if link.is_wheel:
             # can raise InvalidWheelFilename
             wheel = Wheel(link.filename)
-            if not wheel.supported(valid_tags):
+            if not wheel.supported(valid_tags) and not ignore_compatibility:
                 raise UnsupportedWheel(
                     "{} is not a supported wheel for this platform. It "
                     "can't be sorted.".format(wheel.filename)
                 )
             if self._prefer_binary:
                 binary_preference = 1
-            pri = -(wheel.support_index_min(valid_tags))
+            tags = valid_tags
+            try:
+                pri = -(wheel.support_index_min(tags=tags))
+            except TypeError:
+                pri = -(support_num)
             if wheel.build_tag is not None:
                 match = re.match(r'^(\d+)(.*)$', wheel.build_tag)
                 build_tag_groups = match.groups()
@@ -587,6 +597,7 @@ class PackageFinder:
         format_control=None,  # type: Optional[FormatControl]
         candidate_prefs=None,         # type: CandidatePreferences
         ignore_requires_python=None,  # type: Optional[bool]
+        ignore_compatibility=None,  # type: Optional[bool]
     ):
         # type: (...) -> None
         """
@@ -601,6 +612,8 @@ class PackageFinder:
         """
         if candidate_prefs is None:
             candidate_prefs = CandidatePreferences()
+        if ignore_compatibility is None:
+            ignore_compatibility = False
 
         format_control = format_control or FormatControl(set(), set())
 
@@ -609,12 +622,16 @@ class PackageFinder:
         self._ignore_requires_python = ignore_requires_python
         self._link_collector = link_collector
         self._target_python = target_python
+        self._ignore_compatibility = ignore_compatibility
 
         self.format_control = format_control
 
         # These are boring links that have already been logged somehow.
         self._logged_links = set()  # type: Set[Link]
 
+        # Kenneth's Hack
+        self.extra = None
+
     # Don't include an allow_yanked default value to make sure each call
     # site considers whether yanked releases are allowed. This also causes
     # that decision to be made explicit in the calling code, which helps
@@ -652,6 +669,22 @@ class PackageFinder:
             ignore_requires_python=selection_prefs.ignore_requires_python,
         )
 
+    @staticmethod
+    def get_extras_links(links):
+        requires = []
+        extras = {}
+        current_list = requires
+
+        for link in links:
+            if not link:
+                current_list = requires
+            if link.startswith('['):
+                current_list = []
+                extras[link[1:-1]] = current_list
+            else:
+                current_list.append(link)
+        return extras
+
     @property
     def target_python(self):
         # type: () -> TargetPython
@@ -713,6 +746,7 @@ class PackageFinder:
             target_python=self._target_python,
             allow_yanked=self._allow_yanked,
             ignore_requires_python=self._ignore_requires_python,
+            ignore_compatibility=self._ignore_compatibility,
         )
 
     def _sort_links(self, links):
@@ -756,6 +790,7 @@ class PackageFinder:
             name=link_evaluator.project_name,
             link=link,
             version=result,
+            requires_python=getattr(link, "requires_python", None)
         )
 
     def evaluate_links(self, link_evaluator, links):
diff --git a/pipenv/patched/notpip/_internal/models/candidate.py b/pipenv/patched/notpip/_internal/models/candidate.py
index d8a8d42e..a58926ab 100644
--- a/pipenv/patched/notpip/_internal/models/candidate.py
+++ b/pipenv/patched/notpip/_internal/models/candidate.py
@@ -15,11 +15,12 @@ class InstallationCandidate(KeyBasedCompareMixin):
 
     __slots__ = ["name", "version", "link"]
 
-    def __init__(self, name, version, link):
-        # type: (str, str, Link) -> None
+    def __init__(self, name, version, link, requires_python=None):
+        # type: (str, str, Link, Any) -> None
         self.name = name
         self.version = parse_version(version)  # type: _BaseVersion
         self.link = link
+        self.requires_python = requires_python
 
         super().__init__(
             key=(self.name, self.version, self.link),
diff --git a/pipenv/patched/notpip/_internal/operations/prepare.py b/pipenv/patched/notpip/_internal/operations/prepare.py
index dd66fc28..87420ae7 100644
--- a/pipenv/patched/notpip/_internal/operations/prepare.py
+++ b/pipenv/patched/notpip/_internal/operations/prepare.py
@@ -359,13 +359,7 @@ class RequirementPreparer:
         # FIXME: this won't upgrade when there's an existing
         # package unpacked in `req.source_dir`
         if os.path.exists(os.path.join(req.source_dir, 'setup.py')):
-            raise PreviousBuildDirError(
-                "pip can't proceed with requirements '{}' due to a"
-                "pre-existing build directory ({}). This is likely "
-                "due to a previous installation that failed . pip is "
-                "being responsible and not assuming it can delete this. "
-                "Please delete it and try again.".format(req, req.source_dir)
-            )
+            rmtree(req.source_dir)
 
     def _get_linked_req_hashes(self, req):
         # type: (InstallRequirement) -> Hashes
diff --git a/pipenv/patched/notpip/_internal/req/req_set.py b/pipenv/patched/notpip/_internal/req/req_set.py
index fa58be66..c0f6dfb9 100644
--- a/pipenv/patched/notpip/_internal/req/req_set.py
+++ b/pipenv/patched/notpip/_internal/req/req_set.py
@@ -19,8 +19,8 @@ logger = logging.getLogger(__name__)
 
 class RequirementSet:
 
-    def __init__(self, check_supported_wheels=True):
-        # type: (bool) -> None
+    def __init__(self, check_supported_wheels=True, ignore_compatibility=True):
+        # type: (bool, bool) -> None
         """Create a RequirementSet.
         """
 
@@ -28,6 +28,9 @@ class RequirementSet:
         self.check_supported_wheels = check_supported_wheels
 
         self.unnamed_requirements = []  # type: List[InstallRequirement]
+        if ignore_compatibility:
+            self.check_supported_wheels = False
+        self.ignore_compatibility = (check_supported_wheels is False or ignore_compatibility is True)
 
     def __str__(self):
         # type: () -> str
@@ -194,7 +197,7 @@ class RequirementSet:
         if project_name in self.requirements:
             return self.requirements[project_name]
 
-        raise KeyError("No project with the name {name!r}".format(**locals()))
+        pass
 
     @property
     def all_requirements(self):
diff --git a/pipenv/patched/notpip/_internal/utils/logging.py b/pipenv/patched/notpip/_internal/utils/logging.py
index 87b91d23..ca7efa6c 100644
--- a/pipenv/patched/notpip/_internal/utils/logging.py
+++ b/pipenv/patched/notpip/_internal/utils/logging.py
@@ -278,8 +278,8 @@ def setup_logging(verbosity, no_color, user_log_file):
         "stderr": "ext://sys.stderr",
     }
     handler_classes = {
-        "stream": "pip._internal.utils.logging.ColorizedStreamHandler",
-        "file": "pip._internal.utils.logging.BetterRotatingFileHandler",
+        "stream": "pipenv.patched.notpip._internal.utils.logging.ColorizedStreamHandler",
+        "file": "pipenv.patched.notpip._internal.utils.logging.BetterRotatingFileHandler",
     }
     handlers = ["console", "console_errors", "console_subprocess"] + (
         ["user_log"] if include_user_log else []
@@ -290,7 +290,7 @@ def setup_logging(verbosity, no_color, user_log_file):
         "disable_existing_loggers": False,
         "filters": {
             "exclude_warnings": {
-                "()": "pip._internal.utils.logging.MaxLevelFilter",
+                "()": "pipenv.patched.notpip._internal.utils.logging.MaxLevelFilter",
                 "level": logging.WARNING,
             },
             "restrict_to_subprocess": {
@@ -298,7 +298,7 @@ def setup_logging(verbosity, no_color, user_log_file):
                 "name": subprocess_logger.name,
             },
             "exclude_subprocess": {
-                "()": "pip._internal.utils.logging.ExcludeLoggerFilter",
+                "()": "pipenv.patched.notpip._internal.utils.logging.ExcludeLoggerFilter",
                 "name": subprocess_logger.name,
             },
         },
@@ -353,7 +353,7 @@ def setup_logging(verbosity, no_color, user_log_file):
             "handlers": handlers,
         },
         "loggers": {
-            "pip._vendor": {
+            "pipenv.patched.notpip._vendor": {
                 "level": vendored_log_level
             }
         },
diff --git a/pipenv/patched/notpip/_internal/utils/setuptools_build.py b/pipenv/patched/notpip/_internal/utils/setuptools_build.py
index 2a664b00..94dce426 100644
--- a/pipenv/patched/notpip/_internal/utils/setuptools_build.py
+++ b/pipenv/patched/notpip/_internal/utils/setuptools_build.py
@@ -1,3 +1,4 @@
+import os
 import sys
 
 from pip._internal.utils.typing import MYPY_CHECK_RUNNING
@@ -36,7 +37,8 @@ def make_setuptools_shim_args(
     :param unbuffered_output: If True, adds the unbuffered switch to the
      argument list.
     """
-    args = [sys.executable]
+    sys_executable = os.environ.get('PIP_PYTHON_PATH', sys.executable)
+    args = [sys_executable]
     if unbuffered_output:
         args += ["-u"]
     args += ["-c", _SETUPTOOLS_SHIM.format(setup_py_path)]
diff --git a/pipenv/patched/notpip/_internal/utils/temp_dir.py b/pipenv/patched/notpip/_internal/utils/temp_dir.py
index 91b277df..977c06fd 100644
--- a/pipenv/patched/notpip/_internal/utils/temp_dir.py
+++ b/pipenv/patched/notpip/_internal/utils/temp_dir.py
@@ -3,7 +3,9 @@ import itertools
 import logging
 import os.path
 import tempfile
+import warnings
 from contextlib import contextmanager
+from weakref import finalize
 
 from pip._vendor.contextlib2 import ExitStack
 from pip._vendor.six import ensure_text
@@ -142,11 +144,25 @@ class TempDirectory:
         self._deleted = False
         self.delete = delete
         self.kind = kind
+        self._finalizer = None
+        if self._path:
+            self._register_finalizer()
 
         if globally_managed:
             assert _tempdir_manager is not None
             _tempdir_manager.enter_context(self)
 
+    def _register_finalizer(self):
+        if self.delete and self._path:
+            self._finalizer = finalize(
+                self,
+                self._cleanup,
+                self._path,
+                warn_message = None
+            )
+        else:
+            self._finalizer = None
+
     @property
     def path(self):
         # type: () -> str
@@ -155,6 +171,18 @@ class TempDirectory:
         )
         return self._path
 
+    @classmethod
+    def _cleanup(cls, name, warn_message=None):
+        if not os.path.exists(name):
+            return
+        try:
+            rmtree(name)
+        except OSError:
+            pass
+        else:
+            if warn_message:
+                warnings.warn(warn_message, ResourceWarning)
+
     def __repr__(self):
         # type: () -> str
         return f"<{self.__class__.__name__} {self.path!r}>"
@@ -193,19 +221,13 @@ class TempDirectory:
         # type: () -> None
         """Remove the temporary directory created and reset state
         """
-        self._deleted = True
-        if not os.path.exists(self._path):
-            return
-        # Make sure to pass unicode on Python 2 to make the contents also
-        # use unicode, ensuring non-ASCII names and can be represented.
-        # This is only done on Windows because POSIX platforms use bytes
-        # natively for paths, and the bytes-text conversion omission avoids
-        # errors caused by the environment configuring encodings incorrectly.
-        if WINDOWS:
-            rmtree(ensure_text(self._path))
-        else:
-            rmtree(self._path)
-
+        if getattr(self._finalizer, "detach", None) and self._finalizer.detach():
+            if os.path.exists(self._path):
+                self._deleted = True
+                try:
+                    rmtree(self._path)
+                except OSError:
+                    pass
 
 class AdjacentTempDirectory(TempDirectory):
     """Helper class that creates a temporary directory adjacent to a real one.
